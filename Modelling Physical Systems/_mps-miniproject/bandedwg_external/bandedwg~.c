/*bandedwg~ object to perform the karplus-Strong algorithm.Stefania Serafin june 99	*/#include "m_pd.h"#include "math.h"#define BUFSIZE 10000  								// size of the buffer#define R_TWOPI 6.28318530717958647692 				//#define PI 		3.14159265358979323846static t_class *bandedwg_class;typedef struct bandedwg { 	t_object x_obj;	float v_freq;   // frequency of the string, this will determine the length of the delay line	float v_fb;		// Input that will start the KS model	float b_ym1;    // variable storing x[n-1];	float xm1,xm2;  // x[n-1],x[n-2]	float ym1,ym2;	// y[n-1],y[n-2],	int v_posright; // variable storing the position in the delay line	float *delayline;	} t_bandedwg;// most important function of the object is always the perform function// it is the one that calculates the DSP loop.static t_int *bandedwg_perform(t_int *w){  	t_float *fb 	= (t_float *)(w[1]);    // input to the system (noise in the case of original KS)	t_float *freq 	= (t_float *)(w[2]);  	//frequency of the string 	t_float *damp 	= (t_float *)(w[3]);    // damping as coefficient of the lowpass filter	t_float *atten 	= (t_float *)(w[4]);   	// overall attenuation of the system	t_float *out 	= (t_float *)(w[5]);   	//output. 	t_bandedwg *x 	= (t_bandedwg *)(w[6]);    	int n_tick 		= (int)(w[7]);	int posr 		= x->v_posright;    	// posr represents where we currenty are in the buffer. 	int i;	float ynn;	float vin, vh;	float del_tot;	int samp_rperiod;	float srate = 44100;	float fs = 44100;	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 	float B = 0.4;	float fm = 400;	float fb_gain = 0.9;		float y;	float xm1 = x->xm1;	float xm2 = x->xm2;	float ym1 = x->ym1;	float ym2 = x->ym2;	// band pass filter parameters	float phi, R, theta, A0;	int d;	float *delayline;	delayline = x->delayline;		phi 	= 2 * PI * (fm/fs); 												// resonance frequency	R   	= 0.99 - B/2;                                                     	// filter bandwidth	theta 	= acos(2 * R * cos(phi) / (1 + R * R));         					//	A0 		= (1 - R * R) * sin(theta);       									// gain	d 		= floor(fs/fm);                                                		// compute delay line length	// this is the loop that makes the DSP for the karplus strong.	for(i=0; i<n_tick; i++)	{		// check that the delay line length is between zero and the maximum size.		// we do not want a delay line that is less than zero or bigger than BUFSIZE 		if(d<0) 		d = 0;		if(d>BUFSIZE-1) d = BUFSIZE-1;		// get the incoming velocity at the current position (posr) in the delay line		vin = delayline[(posr+i + BUFSIZE - d)% BUFSIZE];		y = A0 * (fb[i] - xm2 + 2 * R * cos(theta) * ym1 - R * R * ym2);		out[i] = y + fb_gain * vin;			                       				// output sample: sum sample to delayed sample		delayline[(posr+i+BUFSIZE)%BUFSIZE] = out[i];							// write back the value to the current position in the buffer		// out[i] = fb[i];       		xm2 = xm1;		xm1 = fb[i];		ym2 = ym1;		ym1 = y;					}	posr = (posr + n_tick) % BUFSIZE;    										// update the variable position	x->b_ym1 		= ym1;    													// write back to the x[n-1] value in the class.	x->v_posright 	= posr;     												// we write it back to the class variable.	x->xm1 = xm1;	x->xm2 = xm2;	x->ym1 = ym1;	x->ym2 = ym2;	out:	return (w+ 8); } // dsp function sets inlets and outlets.// calls perform functionvoid bandedwg_dsp(t_bandedwg *x, t_signal **sp){	dsp_add(bandedwg_perform, 7, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, sp[4]->s_vec, x, sp[0]->s_n);}// function that initializes the buffer and the related space:void bandedwg_init(t_bandedwg *x){	int i;	x->delayline =  (float *) t_getbytes(BUFSIZE*sizeof(float)) ; // allocates space in memory for delay	for(i=0 ; i< BUFSIZE;  i++)	{		x->delayline[i] = 0. ; // initialises content of the buffer to zero	}}// creates a new signal processing objectvoid *bandedwg_new(double f){	t_bandedwg *x = (t_bandedwg *)pd_new(bandedwg_class);		// inlet_new creates its inlets (additional to the first default one)	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal); 	// signal processing inlet	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal); 	// does not need to be dsp inlet	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);	// does not need to be dsp inlet	// floatinlet_new (&x->x_obj, &x->v_freq);                 // third inlet is a float, panning amount	// floatinlet_new (&x->x_obj, &x->f_firstsignal);                 // third inlet is a float, panning amount	outlet_new(&x->x_obj, gensym("signal"));	// initialize variables of the class 	x->v_fb = 0.0;	x->v_posright=0;	x->v_freq = 440;	x->b_ym1 = 0.;    	// initialize the x[n-1] value to zero		x -> xm1 = 0;	x -> xm2 = 0;  		// x[n-1],x[n-2]	x -> ym1 = 0;	x -> ym2 = 0;		// y[n-1],y[n-2],			bandedwg_init(x);		// call the init function		return(x);} // creates the object. Name of the object needs to be specifiedvoid bandedwg_tilde_setup(void){  bandedwg_class = class_new(gensym("bandedwg~"), (t_newmethod)bandedwg_new, 0,			   sizeof(t_bandedwg), 0, A_DEFFLOAT, 0);    class_addmethod(bandedwg_class, nullfn, gensym("signal"), 0);  class_addmethod(bandedwg_class, (t_method)bandedwg_dsp, gensym("dsp"), 0);}