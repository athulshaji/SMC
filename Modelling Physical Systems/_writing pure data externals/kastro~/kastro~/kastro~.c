/*kastro~ object to perform the karplus-Strong algorithm.Stefania Serafin june 99	*/#include "m_pd.h"#include "math.h"#define BUFSIZE 10000  								// size of the buffer#define R_TWOPI 6.28318530717958647692 				//static t_class *kastro_class;typedef struct kastro { 	t_object x_obj;	float v_freq;   // frequency of the string, this will determine the length of the delay line	float v_fb;		// Input that will start the KS model	float b_ym1;    // variable storing x[n-1];	int v_posright; // variable storing the position in the delay line	float *vinut;   // delay line itself	} t_kastro;// most important function of the object is always the perform function// it is the one that calculates the DSP loop.static t_int *kastro_perform(t_int *w){    t_float *fb = (t_float *)(w[1]);     // input to the system (noise in the case of original KS)  t_float *freq = (t_float *)(w[2]);  //frequency of the string   t_float *damp= (t_float *)(w[3]);    // damping as coefficient of the lowpass filter  t_float *atten= (t_float *)(w[4]);   // overall attenuation of the system  t_float *out = (t_float *)(w[5]);   //output.   t_kastro *x = (t_kastro *)(w[6]);      int n_tick = (int)(w[7]);  float ym1 = x->b_ym1;     // need to store the x[n-1] value. take the value from the class.  float *vinut;               // this is the buffer that contains the samples of the string.  int posr=x->v_posright;    // posr represents where we currenty are in the buffer.   vinut=x->vinut;   // the buffer is also taken from the originally defined class.  int i;     float ynn;  float vin, vh;  float del_tot;  int samp_rperiod;	  float srate = 44100;  // this is the loop that makes the DSP for the karplus strong.    for(i=0; i<n_tick; i++)	{	  	  del_tot=srate/(freq[i]);    //total length of the delay line     	  // there migth be problems if srate / frequency is not an integer number.          // therefore we calculate the integer part of the delay line	  samp_rperiod=(int)del_tot;   //integer part of the delay line	  // check that the delay line length is between zero and the maximum  size	  if(samp_rperiod<0) samp_rperiod = 0;	  // we do not want a delay line that is less that zero or bigger than BUFSIZE 	  if(samp_rperiod>BUFSIZE-1) samp_rperiod = BUFSIZE-1;	  //  get the incoming velocity at the current position (posr) in the delay length	  vin = vinut[(posr+i + BUFSIZE - samp_rperiod)% BUFSIZE];	  //check filter's coefficients	if (damp[i]>0.99999) 	  damp[i]=0.999;	if (damp[i]<0.000001) 	  damp[i]=0.000001; 	// check overall attenuation value 	if (atten[i]>1) 	  atten[i]=1;	if (atten[i]<0.00001) 	  atten[i]=0.00001;//low-pass filter for damping// perform lowpass filtering and attenuation.	ynn = atten[i]*(damp[i]*vin +((1-damp[i]) *ym1));		// y[n] = atten* (a* x[n]+(1-a)* x[n-1])        //update		ym1 = vin;  // x[n-1] = x[n];  	vh=fb[i]+ynn;   // calculate the new input considering the effect of the noise.			vinut[(posr+i+BUFSIZE)%BUFSIZE] = vh;	// write back the value to the current position in the buffer        out[i] = vh;    // create the output}    posr=(posr+n_tick)%BUFSIZE;    // update the variable position    x->b_ym1 = ym1;    // write back to the x[n-1] value in the class.    x->v_posright=posr;     // we write it back to the class variable.	out:	return (w+ 8); }  // dsp function sets inlets and outlets. // calls perform function void kastro_dsp(t_kastro *x, t_signal **sp){  dsp_add(kastro_perform, 7, sp[0]->s_vec, sp[1]->s_vec, sp[2]->s_vec, sp[3]->s_vec, sp[4]->s_vec, x, sp[0]->s_n);} // void kastro_fb(t_kastro *x, double f)// {// 	x->v_fb = f;// }// void kastro_freq(t_kastro *x, double f)// {// 	if (f > 0)// 		x->v_freq = f;// 	else// 		x->v_freq = 0.0001;// }// function that initializes the buffer and the related space:void kastro_init(t_kastro *x){int i; x->vinut =  (float *) t_getbytes(BUFSIZE*sizeof(float)) ; // allocates space in memory for delay for(i=0 ; i< BUFSIZE;  i++)	{		x->vinut[i] = 0. ; // initialises content of the buffer to zero	}}// creates a new signal processing objectvoid *kastro_new(double f){	t_kastro *x = (t_kastro *)pd_new(kastro_class);		// inlet_new creates its inlets (additional to the first default one)	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal); 	// signal processing inlet	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal); 	// does not need to be dsp inlet	inlet_new(&x->x_obj, &x->x_obj.ob_pd, &s_signal, &s_signal);	// does not need to be dsp inlet	// floatinlet_new (&x->x_obj, &x->v_freq);                 // third inlet is a float, panning amount	// floatinlet_new (&x->x_obj, &x->f_firstsignal);                 // third inlet is a float, panning amount	outlet_new(&x->x_obj, gensym("signal"));	// initialize variables of the class 	x->v_fb = 0.0;	x->v_posright=0;	x->v_freq = 440;	x->b_ym1 = 0.;    	// initialize the x[n-1] value to zero		kastro_init(x);		// call the init function		return(x);} // creates the object. Name of the object needs to be specifiedvoid kastro_tilde_setup(void){  kastro_class = class_new(gensym("kastro~"), (t_newmethod)kastro_new, 0,			   sizeof(t_kastro), 0, A_DEFFLOAT, 0);    class_addmethod(kastro_class, nullfn, gensym("signal"), 0);  class_addmethod(kastro_class, (t_method)kastro_dsp, gensym("dsp"), 0);}